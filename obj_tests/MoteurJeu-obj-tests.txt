Condition initiales : aucune
	Opérations : L0 = init(1664,1000,1000); //MaxPasJeu
	
			//after all tests without pasJeuCourant(pasJeu())=pasJeuCourant() +1 
				L1=pasJeu(L0,ECommande.DEPLACER, ECommande.DEPLACER, 1, 3, 240, 30)
	Oracle : 
		getMaxPasJeu(L0) == 1664
		getPasJeuCourant(L0) == 0
		LargeurTerrain(L0) == 1000
		HauteurTerrain(L0) == 1000
		
		Pour tout villageois appartenant à numerosVillageois(L0) de i=0 à numerosVillageois(L0).size() :
			- getVillageois(L0,i).getLargeur() == 10
			- getVillageois(L0,i).getHauteur() == 10
			
			V =getVillageois(L0,i)
			
			SI getVillageois(L0,i).getRace() == ERACE.HOMME
				-getVillageois(L0,i).getForce() == 3
				-getVillageois(L0,i).getVitesse() == 4	
				-distance(positionVillageoisX(M, V), positionVillageois(M, V), positionHotelVilleX(M, 2), positionHotelVilleY(M, 2)) <= 51
			
			SI getVillageois(L0,i).getRace() == ERACE.ORC
				-getVillageois(L0,i).getForce() == 4
				-getVillageois(L0,i).getVitesse() == 3
				-distance(positionVillageoisX(M, V), positionVillageois(M, V), positionHotelVilleX(M, 2), positionHotelVilleY(M, 2)) <= 51
			
		Pour toute mine m in numerosMine(L0)
		   Mine::getLargeur(m) == 50
		   Mine::getHauteur(m) == 50
		   
		Pour tout HotelVille hv in HotelVille(L0, 1) V HotelVille(L0, 2)
		   HotelVille::getLargeur(hv) == 50
		   HotelVille::getHauteur(hv) == 50
		   
		HotelVille(1)::appartenance(hv) == HUMAIN
		HotelVille(2)::appartenance(hv) == ORC
		
		MineMinee(L0).size() == numerosVillageois(L0).size()
		
	    VillageoisAttente(L0).size() == numerosVillageois(L0).size()
	    
	    Pour tout x in [0, MineMinee(L0).size()[
		   MineMinee(L0).get(x) == -1
		
		Pour tout x in [0, VillageoisAttente(L0).size()[
		   VillageoisAttente(L0).get(x) == -1
		
		pasJeuCourant(L1) == pasJeuCourant(L0) + 1
		
		
		rapport:
		
			getMaxPasJeu(L0) != 1664
				=>MJ init,Le nombre de pas de jeu n'est pas égale à 1664
			getPasJeuCourant(L0) != 0
				=>MJ init,La valeur du pas courant n'est pas initialiser à 0
			LargeurTerrain(L0) != 1000
				=>MJ init,La valeur de la largeur n'est pas initialiser correctement
			HauteurTerrain(L0) != 1000
				=>MJ init,La valeur du pas courant n'est pas initialiser correctement
		
			Pour tout villageois appartenant à numerosVillageois(L0) de i=0 à numerosVillageois(L0).size() :
				- getVillageois(L0,i).getLargeur() == 10
					=>in moteurJeu init: Le villageois numero i a une largeur mal initialiser
				- getVillageois(L0,i).getHauteur() == 10
					=>in moteurJeu init: Le villageois numero i a une hauteur mal initialiser
			
				V =getVillageois(L0,i)
				
			
				SI getVillageois(L0,i).getRace() == ERACE.HOMME
					-getVillageois(L0,i).getForce() != 3
						=>in moteurJeu init: Le villageois HOMME i a une force mal initialiser
					-getVillageois(L0,i).getVitesse() != 4	
						=>in moteurJeu init: Le villageois HOMME i a une vitesse mal initialiser
					-distance(positionVillageoisX(M, V), positionVillageois(M, V), positionHotelVilleX(M, 2), positionHotelVilleY(M, 2)) <= 51
						=>in moteurJeu init: Le villageois HOMME i est à une dist initialiser trop loin de son hotel de ville
				SI getVillageois(L0,i).getRace() == ERACE.ORC
					-getVillageois(L0,i).getForce() != 4
						=>in moteurJeu init: Le villageois ORC i a une force mal initialiser
					-getVillageois(L0,i).getVitesse() != 3
						=>in moteurJeu init: Le villageois ORC i a une force mal initialiser
					-distance(positionVillageoisX(M, V), positionVillageois(M, V), positionHotelVilleX(M, 2), positionHotelVilleY(M, 2)) <= 51
						=>in moteurJeu init: Le villageois HOMME i est à une dist initialiser trop loin de son hotel de ville
			Pour toute mine m in numerosMine(L0)
		  		Mine::getLargeur(m) != 50
		  			=>in moteurJeu init: La Mine m a une largeur mal initialiser.
		   		Mine::getHauteur(m) != 50
		   			=> in moteurJeu init: La Mine m a une hauteur mal initialiser.
		   
			Pour tout HotelVille hv in HotelVille(L0, 1) V HotelVille(L0, 2)
		  		HotelVille::getLargeur(hv) != 50
		  			=>in moteurJeu init: L hotel de ville hv a une Hauteur a une largeur mal initialiser
		   		HotelVille::getHauteur(hv) != 50
		   			=>in moteurJeu init: L hotel de ville hv a une Hauteur a une largeur mal initialiser
		   
			HotelVille(1)::appartenance(hv) != HUMAIN
				=>in moteurJeu init: L hotel de ville 1 n'appartient pas au HOMME a l'init alors qu'il le devrait
			HotelVille(2)::appartenance(hv) != ORC
				=>in moteurJeu init: L hotel de ville 2 n'appartient pas au ORC a l'init alors qu'il le devrait
			MineMinee(L0).size() != numerosVillageois(L0).size()
				=>in moteurJeu init: size MineMinee non ok car different de size liste villageois
		    VillageoisAttente(L0).size() != numerosVillageois(L0).size()
	    		=>in moteurJeu init: size villageoisAttente non ok car different de size liste villageois
		    Pour tout x in [0, MineMinee(L0).size()[
			   MineMinee(L0).get(x) != -1
				=>in moteurJeu init: le villageois x est entrain de miné (trouver via MineMinee(i) != -1) alors qu'il ne devrait pas
				
			Pour tout x in [0, VillageoisAttente(L0).size()[
		   		VillageoisAttente(L0).get(x) != -1
				=>in moteurJeu init: le villageois x est en attente (trouver via villageoisAttente(i) != -1) alors qu'il ne devrait pas
			
				
			pasJeuCourant(L1) != pasJeuCourant(L0) + 1
				=>in moteurJeu init: pasJeu s'est mal effectué
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 1.1 : entrer dans une mine

Condition initiales :
	L0 = init(1664,1000,1000);
	//bouger le villageois 1 qui est humain a côte de la mine 0
	L1 = positionsVillageois(L0).put(moteurJeu.getVillageois(1), new Point(moteurJeu.positionMineX(moteurJeu.getMine(0)),moteurJeu.positionMineY(moteurJeu.getMine(0))));
		
	
Opérations :
	L2 = pasJeu(L1,ECommande.ENTRERMINE, ECommande.RIEN, 1, 3, 0, 5);
	

Oracle :
	//Le pas jeu implique que la mine 0 du est miné par le villageois 1
	(L2).get(1) == 0

rapport : 
	(L2).get(1) != 0
	 => estEntrerMine a raté

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 2.1 : entrer dans une mine

Condition initiales :
L0 = init(1664,1000,1000);
//on donne une piece d'or au villageois 1, C'est le plus riche des villageois. 
//Mais le devoir l'appelle
//Il doit payer la taxe

//on sait qu'après l'initialisation l'hotel de ville des homme est a 16
V1 = OrHotelVilleBefore = 16; 
L1 = getVillageois(L0,1).setQtor(1);


//LE DEVOIR L APPELLE , IL VA PAYER SES IMPÔT A L'HOTEL DE VILLE (il est tout de même toujours endetté d'un bourse de 1000 PO)

L2 = pasJeu(L1,ECommande.ENTRERHOTELVILLE, ECommande.RIEN, 1, 3, 1, 5);

Oracle :
	//Le fait de payer 1PO a rendu l'hotel de ville des hoome qui passe de 16 a une richesse de 17
	HotelDeVille(L2,1).orRestant() == OrHotelVilleBefore + 1

rapport : 
	HotelDeVille(L2,1).orRestant() != OrHotelVilleBefore + 1
		->EntrerVille n'a pas bien marché , il devrait avoir une gold de plus qu'à l'init
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 3.1 : entrer dans une mine qui ne t'appartient pas		
	
//Une Mine est déjà conquit par les orcs et un pauvre minier HUMAIN se trouvant dans les parages tente d'entrer	
Condition initiales :
L0 = init(1664,1000,1000);
L1 = getMine(L0,0).setAppartenance(ERace.ORC);
//on mets le minier à côté de la mine
L2 =positionsVillageois(L1,1).put(moteurJeu.getVillageois(1), new Point(moteurJeu.positionMineX(moteurJeu.getMine(0)),moteurJeu.positionMineY(moteurJeu.getMine(0))));
				
Opérations :
//le paysans tente venement d'entrée, il est très vite repousser par un champ de force

L3 = pasJeu(L2,ECommande.ENTRERMINE, ECommande.RIEN, 1, 3, 0, 5);

Oracle :
//on a donc toujours une appartenance orc pour la mine
		getMine(L3 , 0).appartenance() == ERace.ORC

rapport : 
	getMine(L3 , 0).appartenance() != ERace.ORC
	  => L'appartenance devrait être ORC ce n'est pas le cas

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 4.1 : entrer dans un Hotel de ville qui ne t'appartient pas		

Condition initiales :
	L0 = init(1664,1000,1000);
	L1 = positionsVillageois(L0).put(moteurJeu.getVillageois(1), new Point(moteurJeu.positionHotelVilleX(2),moteurJeu.positionHotelVilleY(2)));
		
Opérations :
	L2 = pasJeu(L1,ECommande.ENTRERHOTELVILLE, ECommande.RIEN, 1, 3, 2, 5);
Oracle :
	HotelDeVille(L2,2).appartenance() == ERace.ORC

rapport : 
	HotelDeVille(L2,2).appartenance() != ERace.ORC
		=> L'appartenance devrait être ORC pour l'hotel de ville J2 ce n'est pas le cas 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 5.1 : se déplacer 

///On verifit si le villageois 1 a changé de position après la commande
Condition initiales :
	L0 = init(1664,1000,1000);
	P0 = positionsVillageois(L0).get(getVillageois(L0,1));
		
Opérations :
	L1 = pasJeu(L0,ECommande.DEPLACER, ECommande.RIEN, 1, 3, 267 , 5);
Oracle :
	PosBefore.equals(positionsVillageois(L1).get(getVillageois(L1,1))) rend true

rapport : 
	PosBefore.equals(positionsVillageois(L1).get(getVillageois(L1,1))) rend false
		=> test5 : Le villageois 1 ne s'est pas bien déplacé 
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 6.1 : se déplacer sur une muraille

Condition initiales :
	L0 = init(1664,1000,1000);
	L1 = positionsVillageois(L0).put(getVillageois(L0,1), new Point(positionMurailleX(L0,getMuraille(L0,0)),positionMurailleX(L0,getMuraille(L0,0))+15));
		
		
Opérations :
	L2 = pasJeu(L1,ECommande.DEPLACER, ECommande.RIEN, 1, 3, 267 , 5);
Oracle :
	estSurMuraille(positionsVillageois(L2).get(getVillageois(L2,1)))) rend true 

rapport : 
	   estSurMuraille(positionsVillageois(L2).get(getVillageois(L2,1)))) rend false
		=> test6 : le villageois s'est déplacé dans la muraille , c'est impossible 	
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 7.1 : se déplacé en dehors du terrain

Condition initiales :
	L0 = init(1664,1000,1000);
	L1 = positionsVillageois(L0).put(getVillageois(L0,1), new Point(1,1));
	P0 = positionsVillageois(L0).get(getVillageois(L0,1));
		
Opérations :
	L2 = pasJeu(ECommande.DEPLACER, ECommande.RIEN, 1, 3, 49 , 5);  //se deplacer vers le haut
Oracle :
       P0.equals(positionsVillageois(L2).get(getVillageois(L2,1)) rend true
rapport : 
	   P0.equals(positionsVillageois(L2).get(getVillageois(L2,1)) rend false
		=> test7 : le villageois s'est déplacé en dehors du terrain puis doit être remis a sa position d'origine normalement mais ce n'est pas le cas
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 8.1 : entrer dans un hotel de ville abandonné (celui de son équipe)

Condition initiales :
	L0 = init(1664,1000,1000);
	L1 = HotelDeVille(L1,1).abandoned();
	L2 =getVillageois(L2,1).setQtor(1);
		
Opérations :
	L3 = pasJeu(ECommande.ENTRERHOTELVILLE, ECommande.RIEN, 1, 3, 1 , 5);
Oracle :
       HotelDeVille(L3,1).appartenance() == ERace.HUMAIN
rapport : 
	 HotelDeVille(L3,1).appartenance() == ERace.HUMAIN
		=> test8 : le villageois 1 prend possession de son hotel de ville raté
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 9.1 : deplacement même case si ils sont de race différent

Condition initiales :
	L0 = init(1664,1000,1000);
	L1 = positionsVillageois(L0).put(getVillageois(L0,1), new Point(1,1));
	L2 = positionsVillageois(L1).put(getVillageois(L1,3), new Point(1,8));
		
Opérations :
	L3 = pasJeu(ECommande.DEPLACER, ECommande.DEPLACER, 1, 3, 49 , 267);
Oracle :
       positionsVillageois(L3).get(getVillageois(L3,3)).equals(positionsVillageois(L3).get(getVillageois(L3,1))) rend false
rapport : 
	positionsVillageois(L3).get(getVillageois(L3,3)).equals(positionsVillageois(L3).get(getVillageois(L3,1))) rend true
		=>test9 : le villageois 1 HUMAIN et LE VILLAGEOIS 3 ORC , ne sont pas senser être mis sur la meme case et pourtant. 
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Cas de test 10.1 : test hotel de ville abandonné des ennemis 
	 et verifier que la partie est gagné	

Condition initiales :
	L0 = init(1664,1000,1000);
	L1 = moteurJeu.HotelDeVille(2).abandoned();
	L2=moteurJeu.getVillageois(1).setQtor(1);
	L3=positionsVillageois(L2).put(getVillageois(L2,1),new Point(positionHotelVilleX(L2,2),positionHotelVilleY(L2,2) )); 
				
				
		
Opérations :
	L4 =pasJeu(L3,ECommande.DEPLACER, ECommande.RIEN, 1, 3, 49 , 5);
Oracle :
       HotelDeVille(L4,2).appartenance() ==ERace.HUMAIN
       estFini(L4) rend true
rapport : 
	 HotelDeVille(L4,2).appartenance() !=ERace.HUMAIN
	 	=>HOTEL DE VILLE n'est pas DEVENUE HUMAINE alors qu'elle le devrait
	 estFini(L4) rend false
	 	=>partie fini PAS FINI les HOMME DEVRAIT AVOIR GAGNE mais ce n'est pas le cas
	

		